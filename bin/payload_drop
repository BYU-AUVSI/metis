#! /usr/bin/env python

import rospy
from rosplane_msgs.msg import State, Current_Path
from rosflight_msgs.msg import AuxCommand
import numpy as np
import std_srvs.srv
import subprocess
from uav_msgs.srv import PayloadDrop as PayloadDropService

class PayloadDrop():
    def __init__(self):
        self.dropWaypoint = rospy.get_param('DROP_LOCATION')    # the drop waypoint
        self.threshold = 2.0                                    # m, threshold between drop location parameter and rosplane waypoint
        self.ON_APPROACH = False                                # True when the payload drop approach is good
        self.approach_timer = 0                                 # Keeps track of how long ON_APPROACH has been True
        self.approach_threshold = 500                           # Iterations before ON_APPROACH is made False
        self.armed_flag = False
        self.current_path_q = 0
        self.current_position = [0, 0, 0]
        self.drop_wp_redo = True
        self._checksub = rospy.Subscriber('/fixedwing/current_path', Current_Path, self.check)# subscribes to current waypoint from rosplane
        self._statesub = rospy.Subscriber('/state', State, self.stateCallback)# subscribes to current waypoint from rosplane
        self.pub = rospy.Publisher('aux_command', AuxCommand, queue_size=1) #from Trey
        self.com = AuxCommand() #from Trey
        self.com.type_array = '\0\0\0\0\1\1\1\1\1\1\1\1\1\1' #TODO Change most to zeros later
        self.com.values = [1.0]*14 #from Trey
        self.pub.publish(self.com) #from Trey
        self.s = rospy.Service('drop_payload', PayloadDropService, self.drop_payload)

    def drop_payload():
        self.com.values=[-1.0]*14 #from Trey
        self.pub.publish(self.com) #from Trey
        rospy.sleep(0.5) #from Trey
        self.com.values=[1.0]*14 #from Trey
        self.pub.publish(self.com) #from Trey

    def approachanddrop(self):
        """
        This function is called each time a state message
        is received from the /state topic.
        """
        self.dropWaypoint = rospy.get_param('DROP_LOCATION')    # get the current drop waypoint from the payload planner
        self.approachWaypoint = rospy.get_param('APPROACH')     # get the approach waypoint from the payload planner
        current_position = self.current_position                # Current position from State
        if self.drop_wp_redo:
            try:
                # if the payload planner hasn't been run yet, the 'DROP_LOCATION' is a string
                print(np.array(self.dropWaypoint)[0]) # this fails if the drop wayopint is seen as a string
                self.drop_wp_redo = False
                print("drop waypoint = ",self.dropWaypoint)             # payload drop waypoint calculated by payload planner
            except:
                try:
                    print("dropWaypoint is a string")
                    # if it's seen as a string than make it a list
                    self.dropWaypoint = eval(rospy.get_param('DROP_LOCATION'))
                    self.drop_wp_redo = False
                    print("drop waypoint = ",self.dropWaypoint)             # payload drop waypoint calculated by payload planner
                except:
                    # if those didn't work just assume it's not there and make the drop far away
                    print("using defualt drop location value!")
                    self.dropWaypoint = [99999.9,9999.9,99999.9]
                    self.drop_wp_redo = True
                    print("drop waypoint = ",self.dropWaypoint)             # payload drop waypoint calculated by payload planner



        print("distance to drop location = ", np.linalg.norm(np.subtract(current_position,self.dropWaypoint)));

        # this ros parameter must be changed manually to arm by running:
        # `rosparam set /ARMED_AND_READY "true"`
        # this parameter should be set to false to prevent random dropping:
        # `rosparam set /ARMED_AND_READY "false"`
        # self.ARMED_AND_READY = rospy.get_param('ARMED_AND_READY') # get the current value of this rosparam

        # ON_APPROACH will be set when the plane correctly approaches the drop location.

        if rospy.get_param('ARMED_AND_READY'): # and self.armed_flag == False:
            print("Watch out, I'm armed!!")
            # self.armed_flag = True
        else:
            print("I'm not armed!")
            # self.armed_flag == False

        if self.ON_APPROACH:
            if np.linalg.norm(np.subtract(current_position,self.dropWaypoint)) < self.threshold:
                print("IN RANGE!")
                if rospy.get_param('ARMED_AND_READY'):
                    ii = 0
                    # send the command 10 times just to be safe
                    while ii < 10:
                        # drop the payload!
                        print("\n\n\n\n\n  WE HAVE ATTEMPTED PAYLOAD DROP!!!   \n\n\n\n\n")

                        # 'cause we couldn't get a real service call to work
                        # subprocess.call("rosservice call /gpio_0_pulse_actuate", shell=True)

                        #self.drop_payload() <----Use this line if you want to drop the payload using a service

                        self.com.values=[-1.0]*14 #from Trey
                        self.pub.publish(self.com) #from Trey
                        rospy.sleep(0.5) #from Trey
                        self.com.values=[1.0]*14 #from Trey
                        self.pub.publish(self.com) #from Trey

                        # rospy.ServiceProxy('arm_bomb', std_srvs.srv.Trigger)
                        # rospy.ServiceProxy('actuate_drop_bomb', std_srvs.srv.Trigger)
                        ii += 1
                    self.ON_APPROACH = False
                else:
                    print("\n\n\n\n\n  DID NOT DROP BECAUSE NOT ARMED AND READY!!!   \n\n\n\n\n")
                    self.ON_APPROACH = False
            else:
                self.approach_timer += 1
        # check to see if the waypoint we're headed towards is the drop location waypoint
        else:
            print(self.approachWaypoint)
            if np.linalg.norm(np.subtract(current_position,self.approachWaypoint)) < self.threshold*50:
                self.ON_APPROACH = True
                print("ON APPROACH!")

        if self.approach_timer == self.approach_threshold:
            print("OUT OF RANGE")
            self.ON_APPROACH = False
            self.approach_timer = 0

    def stateCallback(self, state):
        self.current_position = state.position
        if self.ON_APPROACH:
            self.approachanddrop()

    def check(self, current_path):
        new_path_q = current_path.q[0]
        if new_path_q != self.current_path_q:
            self.current_path_q = new_path_q
            self.approachanddrop()


#Run the main planner
if __name__ == "__main__":

    rospy.init_node('payload_drop', anonymous=False)
    paylodDrop = PayloadDrop()
    while not rospy.is_shutdown():
        rospy.spin()




'''
#!/usr/bin/env python
import rospy
from rosflight_msgs.msg import AuxCommand
def main():
        rospy.init_node('Dropper') #from Trey
        pub=rospy.Publisher('aux_command', AuxCommand, queue_size=1) #from Trey
        com = AuxCommand() #from Trey
        com.type_array='\0\0\0\0\1\1\1\1\1\1\1\1\1\1' #from Trey

        com.values=[1.0]*14 #from Trey
        pub.publish(com) #from Trey

        rospy.sleep(0.5) #from Trey
        com.values=[-1.0]*14 #from Trey
        rospy.sleep(0.5) #from Trey
        pub.publish(com) #from Trey
        rospy.sleep(0.5) #from Trey
        com.values=[1.0]*14 #from Trey
        pub.publish(com) #from Trey'''
